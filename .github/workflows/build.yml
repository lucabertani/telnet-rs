name: Rust Release

on:
  workflow_dispatch:
  pull_request:

jobs:
  build_and_package:
    name: Build on ${{ matrix.os }} for ${{ matrix.target }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux Build
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
            rust_toolchain: stable
            artifact_name: telnet-rs-linux-x64
            archive_format: tar.gz
          # Windows Build
          - target: x86_64-pc-windows-msvc
            os: windows-latest
            rust_toolchain: stable
            artifact_name: telnet-rs-windows-x64
            archive_format: zip
          # Add other targets here if needed, e.g., macOS
          # - target: x86_64-apple-darwin
          #   os: macos-latest
          #   rust_toolchain: stable
          #   artifact_name: my-app-macos-x64
          #   archive_format: tar.gz


    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Install Rust Toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: ${{ matrix.rust_toolchain }}
          target: ${{ matrix.target }}
          profile: minimal
          override: true

      # Potresti dover installare dipendenze specifiche per il target qui (vedi commento precedente)

      - name: Build Release
        run: |
          cargo build --release --target ${{ matrix.target }}

      # --- Step per packaging su Linux/macOS (usando tar) ---
      - name: Package Artefacts (tar.gz)
        if: runner.os != 'Windows' # Run this step only on non-Windows OS
        shell: bash
        run: |
          ARTIFACT_DIR="target/${{ matrix.target }}/release"
          APP_NAME="telnet-rs" # Replace with your binary name

          # Go into the release directory to make paths relative
          cd "${ARTIFACT_DIR}"

          FILE_TO_ARCHIVE="${APP_NAME}" # No extension for Linux/macOS binary

          # Check if the binary exists
          if [ ! -f "$FILE_TO_ARCHIVE" ]; then
             echo "Error: Binary '$FILE_TO_ARCHIVE' not found in $ARTIFACT_DIR."
             exit 1
          fi

          # Create the archive one directory up (at the root level relative to the checkout)
          ARCHIVE_FILE="../../..//${{ matrix.artifact_name }}.${{ matrix.archive_format }}"
          tar -czvf "$ARCHIVE_FILE" "$FILE_TO_ARCHIVE"

          echo "Created archive: ${ARCHIVE_FILE}"

      # --- Step per packaging su Windows (usando Compress-Archive) ---
      - name: Package Artefacts (zip)
        if: runner.os == 'Windows' # Run this step only on Windows OS
        shell: powershell # Use PowerShell for Windows commands
        run: |
          $ARTIFACT_DIR = "target\${{ matrix.target }}\release"
          $APP_NAME = "telnet-rs" # Replace with your binary name
          $FILE_TO_ARCHIVE = Join-Path -Path $ARTIFACT_DIR -ChildPath "${APP_NAME}.exe"

          # Check if the binary exists
          if (-not (Test-Path $FILE_TO_ARCHIVE)) {
             Write-Host "Error: Binary '$FILE_TO_ARCHIVE' not found."
             exit 1
          }

          # Define the output archive file path (at the root level relative to the checkout)
          $ARCHIVE_FILE = "${{ matrix.artifact_name }}.${{ matrix.archive_format }}"

          # Create the zip archive
          Compress-Archive -Path $FILE_TO_ARCHIVE -DestinationPath $ARCHIVE_FILE

          Write-Host "Created archive: $ARCHIVE_FILE"

      # --- Step per caricare l'artefatto (uguale per entrambi i sistemi operativi) ---
      - name: Upload Artefact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }} # Use the unique name from the matrix
          # The archive file is created at the root of the repository by the packaging steps
          path: ${{ matrix.artifact_name }}.${{ matrix.archive_format }}
          # Optional: set retention-days to save space for older runs
          # retention-days: 7

  # Job separato per creare la release e caricare gli artefatti (rimane quasi invariato)
  create_release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: build_and_package # This job runs ONLY after build_and_package is complete for all targets

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download all build artefacts
        uses: actions/download-artifact@v4
        #with:
          # By default, this downloads all artifacts from the run
          # They will be downloaded into subdirectories named after the artifact names

      - name: List downloaded files (for debugging)
        run: |
          ls -R

      - name: Create Release and Upload Assets
        uses: houseabsolute/actions-rust-release@v0
        with:
          skip_build: true
          skip_test: true
          skip_upload: false
          github_token: ${{ secrets.GITHUB_TOKEN }}
          # The files pattern should still work as download-artifact places them in subdirectories
          files: |
            my-app-linux-x64/*
            my-app-windows-x64/*
          # Add other artifact patterns here if you add more targets to the matrix
          # my-app-macos-x64/*