name: Rust Release

on:
  workflow_dispatch:
  pull_request:

jobs:
  # Job(s) per compilare e impacchettare per ogni piattaforma
  build_and_package:
    name: Build on ${{ matrix.os }} for ${{ matrix.target }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false # Allow other jobs to complete even if one fails
      matrix:
        include:
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
            rust_toolchain: stable
            artifact_name: my-app-linux-x64
            archive_format: tar.gz
            # You might need to install cross-compilation tools here
          - target: x86_64-pc-windows-msvc
            os: windows-latest
            rust_toolchain: stable
            artifact_name: my-app-windows-x64
            archive_format: zip

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Install Rust Toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: ${{ matrix.rust_toolchain }}
          target: ${{ matrix.target }}
          profile: minimal
          override: true

      # Potresti dover installare dipendenze specifiche per il target qui
      # Esempio per Linux cross-compiling (dipende dal tuo progetto):
      # - name: Install Linux dependencies (if needed)
      #   if: startsWith(matrix.target, 'x86_64-unknown-linux-gnu')
      #   run: sudo apt-get update && sudo apt-get install -y libssl-dev pkg-config

      - name: Build Release
        run: |
          cargo build --release --target ${{ matrix.target }}

      - name: Package Release Artefacts
        shell: bash
        run: |
          ARTIFACT_DIR="target/${{ matrix.target }}/release"
          APP_NAME="my-app" # Replace with your binary name

          # Go into the release directory to make paths relative
          cd "${ARTIFACT_DIR}"

          # Name of the file to archive
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            # Add .exe extension for Windows
            FILE_TO_ARCHIVE="${APP_NAME}.exe"
          else
            FILE_TO_ARCHIVE="${APP_NAME}"
          fi

          # Check if the binary exists
          if [ ! -f "$FILE_TO_ARCHIVE" ]; then
             echo "Error: Binary '$FILE_TO_ARCHIVE' not found in $ARTIFACT_DIR."
             exit 1
          fi

          # Create the archive
          ARCHIVE_FILE="${{ matrix.artifact_name }}.${{ matrix.archive_format }}"
          if [[ "${{ matrix.archive_format }}" == "tar.gz" ]]; then
            tar -czvf "../../../${ARCHIVE_FILE}" "$FILE_TO_ARCHIVE"
          elif [[ "${{ matrix.archive_format }}" == "zip" ]]; then
            # For zip, we need to ensure the tool is available (it is on GitHub Actions runners)
            zip "../../../${ARCHIVE_FILE}" "$FILE_TO_ARCHIVE"
          else
             echo "Error: Unsupported archive format '${{ matrix.archive_format }}'."
             exit 1
          fi

          echo "Created archive: ${ARCHIVE_FILE}"

      - name: Upload Artefact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }} # Use the unique name from the matrix
          path: ${{ matrix.artifact_name }}.${{ matrix.archive_format }}
          # Optional: set retention-days to save space for older runs
          # retention-days: 7

  # Job separato per creare la release e caricare gli artefatti
  create_release:
    name: Create GitHub Release
    runs-on: ubuntu-latest # Can run on any OS, ubuntu-latest is common
    needs: build_and_package # This job runs ONLY after build_and_package is complete for all targets

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        # Fetch tags to ensure the action can determine the correct tag
        with:
          fetch-depth: 0

      - name: Download all build artefacts
        uses: actions/download-artifact@v4
        #with:
          # By default, this downloads all artifacts from the run
          # They will be downloaded into subdirectories named after the artifact names

      - name: List downloaded files (for debugging)
        run: |
          ls -R

      - name: Create Release and Upload Assets
        uses: houseabsolute/actions-rust-release@v0
        with:
          # We built and packaged in previous jobs
          skip_build: true
          skip_test: true
          skip_upload: false # Ensure upload is NOT skipped
          # Use GITHUB_TOKEN provided by GitHub Actions
          github_token: ${{ secrets.GITHUB_TOKEN }}
          # Specify the directory to look for files to upload.
          # download-artifact places files in subdirectories named after the artifact.
          # The pattern will find files inside any directory matching the artifact names.
          # Make sure the file name pattern matches what you uploaded.
          files: |
            my-app-linux-x64/*
            my-app-windows-x64/*
          # Additional release notes or body can be added here
          # release_body: |
          #   See the full changelog [here](YOUR_CHANGELOG_URL).